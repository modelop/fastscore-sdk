## -- Engine class -- ##
import json
import time
from ..codec.datatype import avroTypeToAvroSchema, checkData, jsonNodeToAvroType
from ..codec import to_json, from_json, recordset_from_json
import fastscore.errors as errors
from tabulate import tabulate

from binascii import b2a_hex
from os import urandom

from .instance import InstanceBase
from ..constants import MODEL_CONTENT_TYPES, ATTACHMENT_CONTENT_TYPES, \
                        SCHEMA_CONTENT_TYPE, POLICY_CONTENT_TYPES

from fastscore.v1 import EngineApi
from fastscore.v2 import EngineApi as EngineApi2
from fastscore.v1.rest import ApiException
from fastscore.v2.rest import ApiException as ApiException2
from fastscore import FastScoreError

from fastscore.v2.models import ActiveModelInfo
## patch ActiveModelInfo generated by Swagger
def _unload(self):
    self._eng.unload_model()
ActiveModelInfo.unload = _unload

from fastscore.v2.models import ActiveStreamInfo
## patch ActiveStreamInfo generated by Swagger
def _detach(self):
    self._eng.detach_stream(self.slot)
ActiveStreamInfo.detach = _detach

class Engine(InstanceBase):
    """
    An Engine instance.

    """

    # Maximum size for an inline attachment.
    MAX_INLINE_ATTACHMENT = 1024*1024

    def __init__(self, name):
        """
        Constructor for the Engine class.

        Generally, this is not intended to be constructed 'by hand'. Instead,
        Engine instances should be retrieved from Connect.

        :param name: A name for this instance.

        """
        super(Engine, self).__init__(name, 'engine', EngineApi(), EngineApi2())
        self._active_model = None
        self._active_streams = None
        self._policy = Engine.PolicyProxy(self)

    @property
    def state(self):
        """
        The current state of the engine.
        
        :returns: 'INIT', 'RUNNING', 'PAUSED', 'FINISHING', or 'FINISHED'.

        """

        try:
            return self.swg2.engine_state_get(self.name).state.upper()
        except Exception as e:
            raise FastScoreError("Unable to determine engine state", caused_by=e)

    @property
    def active_model(self):
        """
        The currently loaded model information.

        >>> mm = connect.lookup('model-manage')
        >>> engine = connect.lookup('engine')
        >>> print stream.active_model.name
        >>> print stream.active_model.jets

        :returns: An ActiveModelInfo object.

        """

        if self._active_model == None:
            try:
                self._active_model = self.swg2.active_model_get(self.name)
                self._active_model._eng = self
            except Exception as e:
                if isinstance(e, ApiException2) and e.status == 404:
                    return None
                else:
                    raise FastScoreError("Unable to retrieve active model", caused_by=e)
        return self._active_model

    @property
    def active_streams(self):
        """
        A collection of active streams indexed by a slot.

        >>> mm = connect.lookup('model-manage')
        >>> engine = connect.lookup('engine')
        >>> print stream.active_streams[1]

        """

        if self._active_streams == None:
            try:
                d = {}
                for x in self.swg2.active_stream_list(self.name):
                    x._eng = self   # needed for detach()
                    d[x.slot] = x
                self._active_streams = d
            except Exception as e:
                raise FastScoreError("Unable to retrieve active streams", caused_by=e)
        return self._active_streams
    
    def clear(self):
        self._active_model = None
        self._active_streams = None

    def pause(self):
        """
        Pauses the engine. The result depends on the current state of the
        engine. A running engine changes its state to PAUSED. An initializing
        engine will pause upon startup. In all other states the operation is
        ignored.
        
        """

        try:
            self.swg2.engine_pause(self.name)
        except Exception as e:
            raise FastScoreError("Unable to pause the engine", caused_by=e)

    def unpause(self):
        """
        Unpauses the engine.

        """

        try:
            self.swg2.engine_unpause(self.name)
        except Exception as e:
            raise FastScoreError("Unable to unpause the engine", caused_by=e)

    def reset(self):
        """
        Resets the engine. A loaded model is unloaded. All open streams are
        closed. The engine changes its state to INIT.

        """

        try:
            self.swg2.engine_reset(self.name)
        except Exception as e:
            raise FastScoreError("Unable to reset the engine", caused_by=e)

    #TODO Likely, not working - pls review
    def score(self, data, encode=True):
        """
        Scores the data on the currently running model. Requires the input and
        output streams to use the REST transport.

        >>> engine.score(data=[1,2,3])
        [4,5,6]
        >>> engine.score(data=['1', '2', '3'], encode=False)
        ['4', '5', '6']

        :param data: The data to score, e.g. a list of JSON records.
        :param encode: A boolean indicating whether to encode the inputs. If
            True, the input data is encoded to JSON, and the output is decoded
            from JSON.
        :returns: The scored data.
        """
        job_status = self.swg.job_status(instance=self.name)
        if job_status.model == None:
            raise FastScoreError("No currently running model.")

        input_schema = jsonNodeToAvroType(job_status.model.input_schema)
        output_schema = jsonNodeToAvroType(job_status.model.output_schema)

        inputs = []
        if not encode:
            inputs = [x for x in data]
        else:
            inputs = [x for x in to_json(data, input_schema)]
            if job_status.model.recordsets == 'both' or \
               job_status.model.recordsets == 'input':
                inputs += ['{"$fastscore":"set"}']

        input_str = ''
        for datum in inputs:
            input_str += datum.strip() + '\n'
        input_str += '{"$fastscore":"pig"}\n'

        # now we send the input
        self.swg.job_io_input(instance=self.name, data=input_str, id=1)

        # now we retrieve the output
        output = self.swg.job_io_output(instance=self.name, id=1)
        if not encode:
            return [x for x in output.split('\n') if len(x) > 0]
        else:
            outputs = [x for x in output.split('\n') if len(x) > 0]
            if json.loads(outputs[-1]) == {"$fastscore": "pig"}:
                outputs = outputs[:-1]
            if json.loads(outputs[-1]) == {"$fastscore": "set"}:
                outputs = outputs[:-1]
            if job_status.model.recordsets == 'both' or \
               job_status.model.recordsets == 'output':
                return recordset_from_json(outputs, output_schema)
            else:
                return [x for x in from_json(outputs, output_schema)]

    class PolicyProxy(object):
        def __init__(self, eng):
            self._eng = eng

        def set(self, title, mtype, text):
            if title != 'import':
                raise FastScoreError("Only 'import' policy is currently supported")
            if not mtype in POLICY_CONTENT_TYPES:
                raise FastScoreError("Model type '%s' not recognized" % mtype)
            try:
                ct = POLICY_CONTENT_TYPES[mtype]
                self._eng.swg.policy_put(self._eng.name, text, content_type=ct)
            except Exception as e:
                raise FastScoreError("Unable to upload policy", caused_by=e)

        def get(self, title, mtype):
            if title != 'import':
                raise FastScoreError("Only 'import' policy is currently supported")
            if not mtype in POLICY_CONTENT_TYPES:
                raise FastScoreError("Model type '%s' not recognized" % mtype)
            try:
                ct = POLICY_CONTENT_TYPES[mtype]
                return self._eng.swg.policy_get(self._eng.name, accept=ct)
            except Exception as e:
                raise FastScoreError("Unable to retrieve policy", caused_by=e)

    @property
    def policy(self):
        """
        Set/get the import policy.

        >>> engine = connect.lookup('engine-1')
        >>> engine.policy.set('import', 'python', text)
        >>> print engine.policy.get('import', 'python')

        """
        return self._policy

    def load_model(self, model, force_inline=False, embedded_schemas={}, dry_run=False):
        """
        Load a model into this engine.

        :param model: A Model object.
        :param force_inline: If True, force all attachments to load inline. If False,
                        attachments may be loaded by reference.
        :param embedded_schemas: A dict of schemas to send with the request to stop
                        the Engine from contacting Model Manage when resolving schemas.
        :param dry_run: If True, do not actually load the model, check for
                        errors only.
        """

        self._active_model = None   # force reload
        self._active_streams = None

        def maybe_externalize(att):
            ctype = ATTACHMENT_CONTENT_TYPES[att.atype]
            if att.datasize > Engine.MAX_INLINE_ATTACHMENT and not force_inline:

                ## See https://opendatagoup.atlassian.net/wiki/display/FAS/Working+with+large+attachments
                ##
                ## An example of an externalized attachment:
                ##
                ## Content-Type: message/external-body; access-type=x-model-manage; name="att1.zip"
                ## Content-Disposition: attachment; filename="att1.zip"
                ##
                ## Content-Type: application/zip
                ## Content-Length: 1234
                ##

                ext_type = 'message/external-body; ' + \
                       'access-type=x-model-manage; ' + \
                       'ref="urn:fastscore:attachment:%s:%"' % (model.name,att.name)

                body = 'Content-Type: %s\r\n' % ctype + \
                       'Content-Length: %d\r\n' % att.datasize + \
                       '\r\n'

                return (att.name,body,ext_type)
            else:
                ## data retrieved when you touch .datafile property
                with open(att.datafile) as f:
                    body = f.read()
                return (att.name,body,ctype)

        def quirk(name):
            return 'filename' if name == 'attachment' else 'name'

        def multipart_body(parts, boundary):
            noodle = \
              [ '\r\n--' + boundary + '\r\n' + \
                'Content-Disposition: %s; %s="%s"\r\n' % (tag,quirk(name),name) + \
                'Content-Type: %s\r\n' % ctype + \
                '\r\n' + \
                body
                for tag,(name,body,ctype) in parts ]
            noodle.append('\r\n--' + boundary + '--\r\n')
            return ''.join(noodle)

        try:
            ct = MODEL_CONTENT_TYPES[model.mtype]
            attachments = list(model.attachments)
            if len(attachments) == 0 and len(embedded_schemas) == 0:
                data = model.source
                cd = 'x-model; name="%s"' % model.name
                return self.swg.model_load(self.name,
                                           data,
                                           dry_run=dry_run,
                                           content_type=ct,
                                           content_disposition=cd)
            else:
                ## Swagger 2.0 does allow complex multipart requests - craft it manually.
                parts = [ ('attachment',maybe_externalize(x))
                                        for x in attachments ] + \
                        [ ('x-schema',(name,schema,SCHEMA_CONTENT_TYPE))
                                        for name,schema in embedded_schemas.items() ]
                parts.append( ('x-model',(model.name,model.source,ct)) )
                boundary = b2a_hex(urandom(12))
                data = multipart_body(parts, boundary)
                return self.swg.model_load(self.name,
                                           data,
                                           dry_run=dry_run,
                                           content_type='multipart/mixed; boundary=' + boundary)
        except Exception as e:
            raise FastScoreError("Unable to load model '%s'" % model.name, caused_by=e)

    def scale(self, factor):
        """
        Changes the number of running model instances.

        """
        try:
            self.swg2.active_model_scale(self.name, factor)
        except Exception as e:
            raise FastScoreError("Unable to scale model", caused_by=e)

    def unload_model(self):
        try:
            self.swg2.active_model_delete(self.name)
        except Exception as e:
            if isinstance(e, ApiException2) and e.status == 404:
                raise FastScoreError("Model not loaded")
            else:
                raise FastScoreError("Unable to unload model", caused_by=e)

    def attach_stream(self, stream, slot, dry_run=False):
        try:
            cd = 'x-stream; name="%s"' % stream.name
            return self.swg2.active_stream_attach(self.name,
                                                  stream.desc, slot,
                                                  dry_run=dry_run,
                                                  content_disposition=cd)
        except Exception as e:
            raise FastScoreError("Unable to attach stream", caused_by=e)

    def detach_stream(self, slot):
        try:
            self.swg2.active_stream_detach(self.name, slot)
        except Exception as e:
            raise FastScoreError("Unable to detach stream", caused_by=e)

#    def sample_stream(self, stream, n):
#        try:
#            if n:
#                return self.swg.stream_sample(self.name, stream.desc, n=n)
#            else:
#                return self.swg.stream_sample(self.name, stream.desc)
#        except Exception as e:
#            raise FastScoreError("Unable to sample stream", caused_by=e)
#

